Relatório do Trabalho Final - Lab de Arch 2 - 2015

Thiago Miranda RA 379824

Objetivos:

Implementar o algoritmo fornecido em diferentes linguagens e tentar otimiza-lo.
Comparar os tempos de execução nas diferenas implementações e a influencia das otimizações dos compiladores.
Implementar uma versão 'interativa' com GUI.


Sobre as diferentes implementações:

- Vanilla é a implementação original. 

Cpp Improved contém uma versão modificada do algoritmo original. Principais modificações:
- O programa utiliza streams para fazer o IO
- O programa aloca memória para a imagem, invés de acessar o disco para cada 'setColor'
- Somente depois de ter feito todas modificações necessárias a imagem é escrita em disco.
- Constantes e streams foram declaradas como globais.

CSharp é a implementação do algoritmo em C#. O código é otimizado duas vezes. Primeiro na tradução de C# para IL, e depois na tradução do IL pelo JIT Compiler.
As principais modificações dessa versão foram:
- A criação de classes para lidar com a imagem e o formato .pnm
- Uso de estruturas que possibilitam (mas não garantem) a paralelização de granularidade-grossa trechos do código

Zooming é a implementação interativa / com GUI do algoritmo CSharp. Principais modificações:
- Uma gui
- Mudança do esquema de cores Windows 98 para vermelho e preto
- Utilização do formato Bitmap 32bpp
- Controle do máximo de iterações via GUI (tip: de zoom até as coisas ficarem borradas, só então aumente o número de iterações... As coisas vão rápido e, até borarrem, não faz dif se vc calculo 200 ou 3000 iterações)
- Não adianta calcular mais que 10k iterações... A essa altura os limites da aritmetica de ponto flutuante começam a aparecer anyway.


Cada um dos projetos foi compilado com diferentes parametros, e então 'timed' usando o commando Measure-Command da Powershell do Windows.
Os tempos das implementações com arquitetura alvo 32 bits estão no arquivo "Tempos 32".
Os tempos das implementações com arquitetura alvo 64 bits estão no arquivo "Tempos 64".
Gráficos foram feitos usando esses valores, arredondados para baixo.

Comparando código de máquina para ver as otimizações do compilador. Como a versão Vanilla tem um gargalo devido a acessos a disco, a versão C# gera código de máquina só quando é executada (a não ser que ser NGenED), estou comparando o assembly apenas da versão Cpp Improved.

Na pasta Asm tem quatro arquivos. Todas geradas com arquitetura alvo 32 bits. Uma com otimizações desligadas e outra com o máximo de otimizações.
Os arquivos com nome "Relevante" são 'recortes' das versões completas, contendo as partes interessantes do código.

Podemos ver que na versão Ox instruções como "cvtdq2pd" [Convert Packed Signed Doubleword Integers to Packed Double-Precision Floating-Point Values] (linha 28) são utilizadas, euquanto na versão Od não. Isso me faz crer que o compilador conseguiu utilizar SIMD na versão otimizada.
Devido a quantidade massiva de instruções que eu não conheço, minha analise de 'assembly gerado por compilador' será limitada a isso.

Uma observação que gostaria de fazer é: os compiladores de C++ mais recentes conseguem gerar código que faz uso de AVX, enquanto os de C# não.
Como meu computador não da suporte a AVX não foi possivel comparar as diferenças...

Curiosidade:
- Numa conversa com um colega sobre esse trabalho (desenhar o conjunto de mandelbrot) notamos que esse é o tipo de algoritmo que poderia ser 'jogado para uma gpu'. Uma pesquisa rápida no Google mostrou que não só isso é possível como varias pessoas já o fizeram. Por falta de tempo (e paciencia) eu não desenvolvi uma versão que faz uso da GPU, mas de acordo com quem o fez os ganhos de performance são consideraveis. Isso deve-se basicamente a independencia das operações (o resultado de um ponto não afeta o de outro).

Referencias:
- http://blog.nostatic.org/2009/09/fractal-rendering-on-gpu-mandelbrot-and.html
- http://www.ozone3d.net/tutorials/mandelbrot_set_p4.php